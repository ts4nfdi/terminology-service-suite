"use strict";(self.webpackChunk_ts4nfdi_terminology_service_suite=self.webpackChunk_ts4nfdi_terminology_service_suite||[]).push([[65454],{"./src/components/widgets/MetadataWidget/TabWidget/HierarchyWidgetSemLookP/HierarchyWidget.tsx":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{QU:()=>HIERARCHY_WIDGET_DEFAULT_VALUES,qY:()=>HierarchyWidget});var react=__webpack_require__("./node_modules/react/index.js"),text_text=__webpack_require__("./node_modules/@elastic/eui/es/components/text/text.js"),icon=__webpack_require__("./node_modules/@elastic/eui/es/components/icon/icon.js"),loading_spinner=__webpack_require__("./node_modules/@elastic/eui/es/components/loading/loading_spinner.js"),card=__webpack_require__("./node_modules/@elastic/eui/es/components/card/card.js"),provider=__webpack_require__("./node_modules/@elastic/eui/es/components/provider/provider.js"),OlsApi=__webpack_require__("./src/api/OlsApi.ts"),Hierarchy=__webpack_require__("./src/model/interfaces/Hierarchy.ts"),es=__webpack_require__("./node_modules/react-query/es/index.js"),axios=(__webpack_require__("./node_modules/react-dom/index.js"),__webpack_require__("./node_modules/axios/lib/axios.js")),Reified=__webpack_require__("./src/model/Reified.ts");class SkosEntityDataBuilder{static fromTopConcept(obj){return{iri:obj.uri,label:obj.label,hasChildren:obj.hasChildren,parents:[]}}static fromHierarchyResult(obj){return{iri:obj.uri,label:obj.prefLabel,hasChildren:null!=obj.narrower&&obj.narrower.length>0,parents:Reified.A.fromJson(obj.broader)}}static fromPrefAndUriAndChildren(obj,parents){return{iri:obj.uri,label:obj.prefLabel,hasChildren:obj.hasChildren,parents:Reified.A.fromJson(parents)}}static fromLabelAndUriAndChildren(obj,parents){return{iri:obj.uri,label:obj.label,hasChildren:obj.hasChildren,parents:Reified.A.fromJson(parents)}}}class SkosApi{constructor(api){this.axiosInstance=axios.A.create({baseURL:api,headers:{Accept:"application/json"}})}async makeCall(url,config){return(await this.axiosInstance.get(url,config)).data}async buildHierarchyWithIri(props){const{iri,ontologyId,showSiblingsOnInit}=props;if(!ontologyId)throw Error("ontologyId has to be specified for SKOS API.");const rootEntities=[],parentChildRelations=new Map,entitiesData=new Map,allChildrenPresent=new Set,onInitialPath=new Set;if(iri){const broaderTransitive=await this.makeCall(`/${ontologyId}/hierarchy`,{params:{uri:iri,lang:"en",format:"application/json"}}).then((obj=>Object.keys(obj.broaderTransitive).map((key=>obj.broaderTransitive[key]))));for(const node of broaderTransitive){const nodeData=SkosEntityDataBuilder.fromHierarchyResult(node);entitiesData.set(nodeData.iri,nodeData),node.top&&rootEntities.push(nodeData.iri),showSiblingsOnInit||onInitialPath.add(nodeData.iri)}for(const node of broaderTransitive)if(null!=node.narrower){const children=[];for(const childNode of node.narrower){let childNodeData=entitiesData.get(childNode.uri);null==childNodeData?(childNodeData=SkosEntityDataBuilder.fromLabelAndUriAndChildren(childNode,[node.uri]),entitiesData.set(childNodeData.iri,childNodeData)):childNodeData.parents.map((r=>r.value)).includes(node.uri)||childNodeData.parents.push(...Reified.A.fromJson(node.uri)),children.push(childNodeData)}children.sort(((a,b)=>(a.label||a.iri).localeCompare(b.label||b.iri))),parentChildRelations.set(node.uri,children.map((c=>({childIri:c.iri})))),allChildrenPresent.add(node.uri)}}else{const topconcepts=await this.makeCall(`/${ontologyId}/topConcepts`,{params:{lang:"en",format:"application/json"}}).then((obj=>obj.topconcepts));for(const concept of topconcepts)rootEntities.push(concept.uri)}function createTreeNode(entityData,cycleCheck){cycleCheck.add(entityData.iri);const node=new Hierarchy.n(entityData),children=parentChildRelations.get(entityData.iri)||[];if(showSiblingsOnInit)for(const child of children){if(cycleCheck.has(child.childIri)){console.error(`Cyclic tree at entity "${child.childIri}".`);continue}const childData=entitiesData.get(child.childIri);null!=childData&&node.addChild(createTreeNode(childData,cycleCheck))}else for(const child of children){if(cycleCheck.has(child.childIri)){console.error(`Cyclic tree at entity "${child.childIri}".`);continue}const childData=entitiesData.get(child.childIri);null!=childData&&onInitialPath.has(child.childIri)&&node.addChild(createTreeNode(childData,cycleCheck))}return node.loadedChildren.length>0&&(node.expanded=!0),cycleCheck.delete(entityData.iri),node}const cycleCheck=new Set,rootNodes=rootEntities.map((rootEntity=>createTreeNode(entitiesData.get(rootEntity),cycleCheck))).sort(((a,b)=>(a.entityData.label||a.entityData.iri).localeCompare(b.entityData.label||b.entityData.iri)));return new Hierarchy.O({parentChildRelations,entitiesData,allChildrenPresent,roots:rootNodes,api:new SkosApi(this.axiosInstance.getUri()),ontologyId,mainEntityIri:iri,keepExpansionStates:props.keepExpansionStates})}async loadHierarchyChildren(props){const{nodeToExpand,ontologyId}=props;return(await this.makeCall(`/${ontologyId}/children`,{params:{uri:nodeToExpand.entityData.iri,lang:"en",format:"application/json"}})).narrower.map((obj=>SkosEntityDataBuilder.fromPrefAndUriAndChildren(obj,[nodeToExpand.entityData.iri])))}}var util=__webpack_require__("./src/app/util.ts");function HierarchyNodeToEntityData(hierarchyNode){return{iri:hierarchyNode["@id"],label:hierarchyNode.prefLabel,hasChildren:hierarchyNode.hasChildren,parents:[]}}class OntoPortalApi{constructor(api,apiKey){this.axiosInstance=axios.A.create({baseURL:api,headers:{Accept:"application/json"}}),this.apiKey=apiKey,this.axiosInstance.interceptors.request.use((config=>(config.params=config.params||{},config.params.apikey=this.apiKey,config.params.format="json",config)))}async makeCall(url,config){return(await this.axiosInstance.get(url,config)).data}async buildHierarchyWithIri(props){const{iri,ontologyId,entityType,showSiblingsOnInit}=props;if(!ontologyId)throw Error("ontologyId has to be specified for OntoPortal API.");if(!entityType)throw Error("entityType has to be specified for OntoPortal API.");const rootEntities=[],entitiesData=new Map,parentChildRelations=new Map,allChildrenPresent=new Set,onInitialPath=new Set;function buildRelations(currNode){if(entitiesData.set(currNode["@id"],HierarchyNodeToEntityData(currNode)),currNode.hasChildren&&currNode.children.length>0){parentChildRelations.set(currNode["@id"],currNode.children.map((c=>({childIri:c["@id"]})))),allChildrenPresent.add(currNode["@id"]),onInitialPath.add(currNode["@id"]);for(const child of currNode.children)buildRelations(child)}}if(iri){const api_tree=await this.makeCall(`/ontologies/${ontologyId.toUpperCase()}/${(0,util.DW)(entityType,!1)}/${encodeURIComponent(iri)}/tree`,{params:{include:"@id,prefLabel,hasChildren,children"}});for(const rootNode of api_tree)rootEntities.push(rootNode["@id"]),onInitialPath.add(rootNode["@id"]),buildRelations(rootNode);onInitialPath.add(iri)}else{const roots=await this.makeCall(`/ontologies/${ontologyId.toUpperCase()}/${(0,util.DW)(entityType,!1)}/roots`,{params:{include:"@id,prefLabel,hasChildren"}});for(const rootNode of roots)rootEntities.push(rootNode["@id"]),onInitialPath.add(rootNode["@id"])}function createTreeNode(entityData,cycleCheck){cycleCheck.add(entityData.iri);const node=new Hierarchy.n(entityData),children=parentChildRelations.get(entityData.iri)||[];if(showSiblingsOnInit)for(const child of children)cycleCheck.has(child.childIri)?console.error(`Cyclic tree at entity "${child.childIri}".`):node.addChild(createTreeNode(entitiesData.get(child.childIri),cycleCheck));else for(const child of children)cycleCheck.has(child.childIri)?console.error(`Cyclic tree at entity "${child.childIri}".`):onInitialPath.has(child.childIri)&&node.addChild(createTreeNode(entitiesData.get(child.childIri),cycleCheck));return node.loadedChildren.length>0&&(node.expanded=!0),cycleCheck.delete(entityData.iri),node}const cycleCheck=new Set,rootNodes=rootEntities.map((rootEntity=>createTreeNode(entitiesData.get(rootEntity),cycleCheck))).sort(((a,b)=>(a.entityData.label||a.entityData.iri).localeCompare(b.entityData.label||b.entityData.iri)));return new Hierarchy.O({parentChildRelations,entitiesData,allChildrenPresent,roots:rootNodes,api:new OntoPortalApi(this.axiosInstance.getUri(),this.apiKey),ontologyId,mainEntityIri:iri,keepExpansionStates:props.keepExpansionStates,entityType})}async loadHierarchyChildren(props){const{nodeToExpand,ontologyId,entityType}=props;if(null==entityType)throw Error("entityType has to be provided to load children in an OntoPortal hierarchy.");return(await this.makeCall(`/ontologies/${ontologyId.toUpperCase()}/${(0,util.DW)(entityType,!1)}/${encodeURIComponent(nodeToExpand.entityData.iri)}/children`,{params:{include:"@id,prefLabel,hasChildren"}})).collection.map((child=>HierarchyNodeToEntityData(child)))}}__webpack_require__("./src/style/semlookp-styles.css");var ModelTypeCheck=__webpack_require__("./src/model/ModelTypeCheck.ts"),jsx_runtime=__webpack_require__("./node_modules/react/jsx-runtime.js");const HIERARCHY_WIDGET_DEFAULT_VALUES={INCLUDE_OBSOLETE_ENTITIES:!1,PREFERRED_ROOTS:!1,KEEP_EXPANSION_STATES:!1,SHOW_SIBLINGS_ON_INIT:!1,USE_LEGACY:!1};function TreeLink(props){let definedBy=props.entityData.definedBy||[];return definedBy.includes(props.ontologyId)&&(definedBy=[]),(0,jsx_runtime.jsxs)(jsx_runtime.Fragment,{children:[(0,jsx_runtime.jsxs)("span",{className:props.highlight?"highlight":void 0,children:["http://purl.obolibrary.org/obo/BFO_0000050"==props.childRelationToParent&&(0,jsx_runtime.jsxs)(jsx_runtime.Fragment,{children:[(0,jsx_runtime.jsx)("span",{style:{marginInlineStart:"1.5px",marginTop:"2.5px"},className:"surroundCircle",children:" P "})," "]}),"http://www.w3.org/1999/02/22-rdf-syntax-ns#type"==props.childRelationToParent&&(0,jsx_runtime.jsxs)(jsx_runtime.Fragment,{children:[(0,jsx_runtime.jsx)("span",{style:{marginInlineStart:"1.5px",marginTop:"2.5px"},className:"surroundCircle",children:"I"})," "]}),(0,jsx_runtime.jsx)("button",{onClick:()=>{props.onNavigateToEntity&&props.onNavigateToEntity(props.ontologyId,props.entityType||"",props.entityData)},children:(0,jsx_runtime.jsxs)("span",{children:[" ",props.entityData.label||props.entityData.iri," "]})})]}),definedBy.length>0&&(0,jsx_runtime.jsxs)(jsx_runtime.Fragment,{children:[" ",definedBy.map((definingOntology=>(0,jsx_runtime.jsx)("button",{onClick:()=>{props.onNavigateToOntology&&props.onNavigateToOntology(definingOntology,props.entityType||"",props.entityData)},children:(0,jsx_runtime.jsx)("span",{className:"ontology-badge",children:definingOntology.toUpperCase()})},`${props.entityData.iri}:${definingOntology}`)))]})]})}function HierarchyWidget(props){const{apiUrl,backendType,apiKey,onNavigateToEntity,onNavigateToOntology,iri,ontologyId,entityType,includeObsoleteEntities=HIERARCHY_WIDGET_DEFAULT_VALUES.INCLUDE_OBSOLETE_ENTITIES,preferredRoots=HIERARCHY_WIDGET_DEFAULT_VALUES.PREFERRED_ROOTS,keepExpansionStates=HIERARCHY_WIDGET_DEFAULT_VALUES.KEEP_EXPANSION_STATES,showSiblingsOnInit=HIERARCHY_WIDGET_DEFAULT_VALUES.SHOW_SIBLINGS_ON_INIT,useLegacy=HIERARCHY_WIDGET_DEFAULT_VALUES.USE_LEGACY}=props,[,forceUpdate]=(0,react.useReducer)((x=>x+1%Number.MAX_SAFE_INTEGER),0),api=(0,react.useMemo)((()=>{switch(backendType){case"ols":default:return new OlsApi.l(apiUrl);case"skosmos":return new SkosApi(apiUrl);case"ontoportal":return new OntoPortalApi(apiUrl,apiKey||"")}}),[apiUrl,backendType,apiKey]),{data:hierarchy,isSuccess:isSuccessHierarchy}=(0,es.useQuery)(["hierarchySemLookP",iri,entityType,ontologyId,preferredRoots,includeObsoleteEntities,keepExpansionStates,showSiblingsOnInit,useLegacy],(async function getNewHierarchy(){return await api.buildHierarchyWithIri({ontologyId,iri,entityType,preferredRoots,includeObsoleteEntities,keepExpansionStates,showSiblingsOnInit,useLegacy})})),toggleNode=(0,react.useCallback)((node=>{if(!(hierarchy instanceof Hierarchy.O))throw Error("Hierarchy object was undefined while trying to expand a tree node. This should never happen.");hierarchy.entityType&&(0,ModelTypeCheck.Td)(hierarchy.entityType)||(node.expanded=!node.expanded,node.expanded?(node.loading=!0,forceUpdate(),hierarchy.fetchInformationForExpansion(node).then((()=>{node.loading=!1,forceUpdate()}))):(forceUpdate(),hierarchy.closeNode(node)))}),[hierarchy]);function renderTreeNode(hierarchy,node,drawLine){return(0,jsx_runtime.jsxs)("div",{children:[(0,jsx_runtime.jsx)(text_text.b,{children:(0,jsx_runtime.jsxs)("div",{style:{height:"24px"},children:[(0,jsx_runtime.jsx)("div",{style:{position:"relative",borderLeft:"1px dotted black",borderBottom:"1px dotted black",width:"12px",height:"16px",left:"5.5px",top:"-1px"}}),(0,jsx_runtime.jsx)("div",{style:{position:"relative",borderLeft:drawLine?"1px dotted black":"",width:"12px",height:"9px",left:"5.5px",top:"0px"}}),(0,jsx_runtime.jsxs)("div",{style:{position:"relative",top:"-22px"},children:[(0,jsx_runtime.jsx)("span",{children:node.entityData.hasChildren?(0,jsx_runtime.jsx)("button",{style:{},onClick:()=>{toggleNode(node)},children:(0,jsx_runtime.jsx)(icon.BJ,{type:node.expanded?"arrowDown":"arrowRight",size:"s"})}):(0,jsx_runtime.jsx)(icon.BJ,{type:"empty"})})," ",(0,jsx_runtime.jsx)(TreeLink,{entityData:node.entityData,childRelationToParent:node.childRelationToParent,ontologyId:hierarchy.ontologyId,entityType:hierarchy.entityType,onNavigateToEntity,onNavigateToOntology,highlight:node.entityData.iri==hierarchy?.mainEntityIri})," ",null!=node.entityData.numDescendants&&node.entityData.numDescendants>0&&(0,jsx_runtime.jsxs)("span",{style:{color:"gray"},children:["(",node.entityData.numDescendants.toLocaleString(),")"]})]})]})}),node.expanded&&(0,jsx_runtime.jsx)("ul",{style:{marginBlockEnd:"0",marginInlineStart:"5.5px"},children:node.loading?(0,jsx_runtime.jsx)(loading_spinner.V,{style:{position:"relative",left:"13px",top:"5px"}}):node.loadedChildren.map(((child,idx)=>(0,jsx_runtime.jsx)("div",{style:{borderLeft:drawLine?"1px dotted black":"",paddingLeft:"1rem"},children:renderTreeNode(hierarchy,child,idx<node.loadedChildren.length-1)},(0,util.DU)())))})]},(0,util.DU)())}return(0,jsx_runtime.jsx)(card.Gm,{title:"",layout:"horizontal",style:{overflowX:"auto",overflowY:"hidden"},children:isSuccessHierarchy&&null!=hierarchy?(0,jsx_runtime.jsxs)(text_text.b,{style:{whiteSpace:"nowrap"},children:[" ",hierarchy.roots.map(((rootNode,idx)=>renderTreeNode(hierarchy,rootNode,idx<hierarchy.roots.length-1)))]}):(0,jsx_runtime.jsx)(loading_spinner.V,{})})}function WrappedHierarchyWidget(props){const queryClient=new es.QueryClient;return(0,jsx_runtime.jsx)(provider.l,{colorMode:"light",children:(0,jsx_runtime.jsx)(es.QueryClientProvider,{client:queryClient,children:(0,jsx_runtime.jsx)(HierarchyWidget,{apiUrl:props.apiUrl,apiKey:props.apiKey,backendType:props.backendType,iri:props.iri,entityType:props.entityType,ontologyId:props.ontologyId,includeObsoleteEntities:props.includeObsoleteEntities,useLegacy:props.useLegacy,preferredRoots:props.preferredRoots,keepExpansionStates:props.keepExpansionStates,showSiblingsOnInit:props.showSiblingsOnInit,onNavigateToEntity:props.onNavigateToEntity,onNavigateToOntology:props.onNavigateToOntology})})})}HierarchyWidget.displayName="HierarchyWidget",WrappedHierarchyWidget.displayName="WrappedHierarchyWidget",HierarchyWidget.__docgenInfo={description:"",methods:[],displayName:"HierarchyWidget",props:{apiUrl:{required:!0,tsType:{name:"string"},description:"The API URL for the API call."},apiKey:{required:!1,tsType:{name:"string"},description:"**Only required for OntoPortal hierarchies**\nAn API key is required to access the OntoPortal API. To obtain an API key for the BioPortal REST API, see https://www.bioontology.org/wiki/BioPortal_Help#Getting_an_API_key"},backendType:{required:!1,tsType:{name:"string"},description:"The backend key from which to request `{ols, ontoportal, skosmos}`. Default is `ols`"},entityType:{required:!1,tsType:{name:"entityTypeNames[number]",raw:"typeof entityTypeNames[number]"},description:"Mandatory: OntoPortal\n\nOptional: OLS\n\nUnused: Skosmos"},ontologyId:{required:!1,tsType:{name:"string"},description:"Mandatory: OntoPortal, Skosmos\n\nOptional: OLS (however, it is still strongly recommended to provide)"},includeObsoleteEntities:{required:!1,tsType:{name:"boolean"},description:"**Only affecting OLS hierarchies**\nToggle whether to include entities marked as obsolete by the API."},useLegacy:{required:!1,tsType:{name:"boolean"},description:"**Only affecting OLS hierarchies**\nToggle between OLS3 (legacy) and OLS4 API versions."},preferredRoots:{required:!1,tsType:{name:"boolean"},description:"**Only affecting OLS hierarchies**\nWhen displaying an ontology's root hierarchy (i.e. no iri provided), all entities without parent entities are displayed by default.\nIf `preferredRoots==true`, only the entities specifically marked as preferred root entity by the API are shown."},keepExpansionStates:{required:!1,tsType:{name:"boolean"},description:"If true, the expanded subtree of a node which gets closed stays expanded on re-expansion of this node.\nOtherwise, if a node is closed, only the direct children will be shown on re-expansion."},showSiblingsOnInit:{required:!1,tsType:{name:"boolean"},description:"If false, only the entity with specified iri and its ancestors are displayed in a hierarchy.\nIf true, the siblings of every entity mentioned above is displayed as well (NOTE: this might, but does not have to, need more queries to the API)."},iri:{required:!1,tsType:{name:"string"},description:"If provided, a hierarchy for the corresponding entity will be displayed, in which this entity is highlighted.\nOtherwise, the root entities for the specified ontology and entityType will be displayed."},onNavigateToEntity:{required:!1,tsType:{name:"signature",type:"function",raw:"(ontologyId: string, entityType?: string, entity?: EntityData) => void",signature:{arguments:[{type:{name:"string"},name:"ontologyId"},{type:{name:"string"},name:"entityType"},{type:{name:"signature",type:"object",raw:"{\n  iri: string;\n  label?: string;\n  definedBy?: string[];\n  /**\n   * should be present for use with hierarchy\n   */\n  hasChildren?: boolean;\n  numDescendants?: number;\n  /**\n   * should be present for use with hierarchy\n   */\n  parents?: Reified<string>[];\n}",signature:{properties:[{key:"iri",value:{name:"string",required:!0}},{key:"label",value:{name:"string",required:!1}},{key:"definedBy",value:{name:"Array",elements:[{name:"string"}],raw:"string[]",required:!1}},{key:"hasChildren",value:{name:"boolean",required:!1},description:"should be present for use with hierarchy"},{key:"numDescendants",value:{name:"number",required:!1}},{key:"parents",value:{name:"Array",elements:[{name:"Reified",elements:[{name:"string"}],raw:"Reified<string>"}],raw:"Reified<string>[]",required:!1},description:"should be present for use with hierarchy"}]}},name:"entity"}],return:{name:"void"}}},description:"This function is called every time an entity link is clicked\n@param ontologyId obtains the ontologyId of the current ontology\n@param entityType obtains the entityType of the clicked entity\n@param entity.iri obtains the iri of the clicked entity\n@param entity.label obtains the label of the clicked entity\n@param entity.definedBy obtains the list of ontologies the clicked entity is defined in (only OLS)\n@param entity.hasChildren obtains a boolean indicating whether the clicked entity has child entities\n@param entity.numDescendants obtains the number of hierarchical descendants of the clicked entity (only OLS)\n@param entity.parents obtains the list of parent entities of the clicked entity (only OLS, Skosmos)"},onNavigateToOntology:{required:!1,tsType:{name:"signature",type:"function",raw:"(ontologyId: string, entityType?: string, entity?: EntityData) => void",signature:{arguments:[{type:{name:"string"},name:"ontologyId"},{type:{name:"string"},name:"entityType"},{type:{name:"signature",type:"object",raw:"{\n  iri: string;\n  label?: string;\n  definedBy?: string[];\n  /**\n   * should be present for use with hierarchy\n   */\n  hasChildren?: boolean;\n  numDescendants?: number;\n  /**\n   * should be present for use with hierarchy\n   */\n  parents?: Reified<string>[];\n}",signature:{properties:[{key:"iri",value:{name:"string",required:!0}},{key:"label",value:{name:"string",required:!1}},{key:"definedBy",value:{name:"Array",elements:[{name:"string"}],raw:"string[]",required:!1}},{key:"hasChildren",value:{name:"boolean",required:!1},description:"should be present for use with hierarchy"},{key:"numDescendants",value:{name:"number",required:!1}},{key:"parents",value:{name:"Array",elements:[{name:"Reified",elements:[{name:"string"}],raw:"Reified<string>"}],raw:"Reified<string>[]",required:!1},description:"should be present for use with hierarchy"}]}},name:"entity"}],return:{name:"void"}}},description:"This function is called every time an entity link is clicked\n@param ontologyId obtains the ontologyId of the clicked badge\n@param entityType obtains the entityType of the clicked badge\n@param entity.iri obtains the iri of the clicked badge (can be empty)\n@param entity.label obtains the label of the clicked badge\n@param entity.definedBy obtains the list of ontologies the clicked entity is defined in (only OLS)\n@param entity.hasChildren obtains a boolean indicating whether the clicked entity has child entities\n@param entity.numDescendants obtains the number of hierarchical descendants of the clicked entity (only OLS)\n@param entity.parents obtains the list of parent entities of the clicked entity (only OLS, Skosmos)"}}}}}]);